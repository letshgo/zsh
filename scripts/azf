#!/usr/bin/env bash
set -euo pipefail

# Filter Azure VMs using jq with arbitrary key=value predicates supplied as positional args.
# Supports nested keys (e.g., osProfile.computerName, tags.env) and regex with ~= operator.
#
# Examples:
#   ./filter-azure-vms.sh name=myvm
#   ./filter-azure-vms.sh location=westeurope powerState=VM running # (see note below)
#   ./filter-azure-vms.sh "tags.env=prod" "hardwareProfile.vmSize=Standard_D2s_v5"
#   ./filter-azure-vms.sh osProfile.osType=Linux
#   ./filter-azure-vms.sh name~='^web-\d+$' location=~'europe$'
#
# You can also scope the query:
#   ./filter-azure-vms.sh --subscription SUB_ID --resource-group RG name=myvm
#
# Notes:
#   - Equals operator: key=value (string match, case-sensitive by default)
#   - Regex operator:  key~=REGEX (ECMA regex, case-sensitive unless (?i) is used)
#   - To do case-insensitive equals, use regex like key~=^(?i)value$
#   - Tags: use tags.<key>=<value>, e.g., tags.env=prod
#   - powerState is exposed in -d output as "powerState": "VM deallocated"/"VM running", etc.

usage() {
  cat <<'EOF'
Usage:
  filter-azure-vms.sh [--subscription SUB] [--resource-group RG] [--all] [--raw] [--names] [--wide] [--help] [predicates...]

Predicates (positional):
  key=value        Exact (case-sensitive) string match
  key~=REGEX       Regex match (jq test/ECMA). For case-insensitive, use (?i) in the regex.
  Nested keys allowed: e.g. osProfile.computerName, storageProfile.osDisk.osType, tags.env

Options:
  --subscription SUB     Azure subscription ID or name to use
  --resource-group RG    Restrict to a specific resource group
  --all                  Query all subscriptions (uses 'az account list' then iterates)
  --raw                  Output full VM JSON that matched (array)
  --names                Output only VM names (one per line)
  --wide                 Output a concise table: name, resourceGroup, location, powerState, vmSize, osType
  --help                 Show this help

Examples:
  filter-azure-vms.sh name=myvm
  filter-azure-vms.sh --resource-group rg-app tags.env=prod
  filter-azure-vms.sh --wide osProfile.osType=Linux hardwareProfile.vmSize=Standard_D2s_v5
  filter-azure-vms.sh name~=^web-\\d+$ location~=europe$
EOF
}

sub=""
rg=""
mode="raw" # raw|names|wide
scope="single" # single|all
predicates=()

while (( "$#" )); do
  case "$1" in
    --help|-h) usage; exit 0 ;;
    --subscription) sub="${2:-}"; shift 2 ;;
    --resource-group) rg="${2:-}"; shift 2 ;;
    --all) scope="all"; shift ;;
    --raw) mode="raw"; shift ;;
    --names) mode="names"; shift ;;
    --wide) mode="wide"; shift ;;
    --) shift; break ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      exit 1
      ;;
    *)
      predicates+=("$1"); shift ;;
  esac
done

# Build a jq filter expression from predicates
# Supports:
#   key=value  -> .key == "value"
#   key~=regex -> (.key|tostring) | test("regex")
#
# For nested keys like a.b.c, we convert to .a?.b?.c? with safe navigation using // empty
# and evaluate strings using tostring to avoid null issues in regex.

build_jq_field() {
  local key="$1"
  # convert dot paths into .a? .b? .c?
  local IFS='.'
  read -ra parts <<< "$key"
  local path="."
  for p in "${parts[@]}"; do
    # Allow keys that might contain dashes by using .["key"]
    if [[ "$p" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
      path+="${path:+}${p:+}.${p}?"
    else
      path+="${path:+}.\"$p\"?"
    fi
  done
  echo "$path"
}

jq_predicate='true'
for pred in "${predicates[@]}"; do
  if [[ "$pred" == *"~="* ]]; then
    key="${pred%%~=*}"
    regex="${pred#*~=}"
    field=$(build_jq_field "$key")
    # Use tostring to handle numbers/null gracefully for regex
    jq_predicate+=" and ( ($field // empty) | tostring | test(\"$regex\") )"
  elif [[ "$pred" == *"="* ]]; then
    key="${pred%%=*}"
    val="${pred#*=}"
    field=$(build_jq_field "$key")
    # String equality (case-sensitive). If you need numeric compare, pass regex or adjust here.
    # We compare after tostring to be consistent across types.
    jq_predicate+=" and ( ($field // empty) | tostring == \"$val\" )"
  else
    echo "Invalid predicate: '$pred' (use key=value or key~=regex)" >&2
    exit 1
  fi
done

# Compose az command(s)
list_cmd_base=(az vm list -d -o json)
if [[ -n "$rg" ]]; then
  list_cmd_base+=(--resource-group "$rg")
fi

collect_vms() {
  if [[ "$scope" == "all" ]]; then
    # Iterate all subscriptions
    mapfile -t subs < <(az account list --all -o tsv --query '[].id')
    if [[ "${#subs[@]}" -eq 0 ]]; then
      echo "[]" ; return
    fi
    # Concatenate results from each subscription
    tmp=$(mktemp)
    echo "[]" > "$tmp"
    for s in "${subs[@]}"; do
      # shellcheck disable=SC2086
      vms=$(AZURE_CORE_ONLY_SHOW_ERRORS=1 az account set -s "$s" >/dev/null 2>&1; "${list_cmd_base[@]}" || echo "[]")
      # Merge arrays
      jq -c --argjson arr "$vms" '. + $arr' "$tmp" > "${tmp}.new" && mv "${tmp}.new" "$tmp"
    done
    cat "$tmp"
    rm -f "$tmp"
  else
    # Single subscription (optionally set)
    if [[ -n "$sub" ]]; then
      az account set -s "$sub" >/dev/null
    fi
    "${list_cmd_base[@]}"
  fi
}

vms_json=$(collect_vms)

# Apply jq predicate
filtered=$(jq --argjson dummy 0 -c "[ .[] | select( $jq_predicate ) ]" <<<"$vms_json")

# Output modes
case "$mode" in
  raw)
    echo "$filtered"
    ;;
  names)
    echo "$filtered" | jq -r '.[].name'
    ;;
  wide)
    # Compose a handy table with common fields; safely handle nulls
    echo "$filtered" | jq -r '
      (["name","resourceGroup","location","powerState","vmSize","osType"] | @tsv),
      (.[] | {
        name: (.name // ""),
        resourceGroup: (.resourceGroup // ""),
        location: (.location // ""),
        powerState: (.powerState // ""),
        vmSize: (.hardwareProfile.vmSize // ""),
        osType: (.storageProfile.osDisk.osType // .storageProfile.osProfile?.osType // "")
      } | [.name,.resourceGroup,.location,.powerState,.vmSize,.osType] | @tsv)
    ' | column -t
    ;;
  *)
    echo "$filtered"
    ;;
esac
